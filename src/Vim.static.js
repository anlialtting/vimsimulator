Object.entries({"Vim/StyleManager.js":"function StyleManager(){\n    this.style=document.createElement('style')\n}\nStyleManager.prototype.appendChild=function(n){\n    this.style.appendChild(n)\n}\nStyleManager\n","Vim/UndoBranchManager.js":"function UndoBranchManager(){\n    this._undoBranches=[]\n}\nUndoBranchManager.prototype.clear=function(){\n    this._undoBranches=[]\n    delete this.current\n}\nUndoBranchManager.prototype.push=function(text){\n    let b=new UndoBranch(text)\n    this._undoBranches.push(b)\n    if(this.current!=undefined){\n        this.current.next=b\n        b.previous=this.current\n    }\n    this.current=b\n}\nUndoBranchManager.prototype.gotoPrevious=function(){\n    if(this.current.previous!=undefined){\n        let b=this.current.previous\n        this.current=b\n        return b.text\n    }\n}\nfunction UndoBranch(text){\n    this.text=text\n}\nUndoBranchManager\n","Vim/colors.css":"div.webvim.cli{\n    --color3i:yellow;\n    --color4:blue;\n    --color4i:dodgerblue;\n    --background-color:black;\n    --foreground-color:lightgray;\n    --middle-color:gray;\n    --cursor-bg:var(--foreground-color);\n    --cursor-fg:var(--background-color);\n}\ndiv.webvim.cli .color4i{\n    color:var(--color4i);\n    --cursor-bg:var(--color4i);\n    --cursor-fg:var(--background-color);\n}\ndiv.webvim.cli .cursor{\n    background-color:var(--cursor-bg);\n    color:var(--cursor-fg);\n}\n","Vim/createCursor/VimCursor.js":"function Cursor(vim){\n    this._x=0\n    this._y=0\n}\n// start 0\nObject.defineProperty(Cursor.prototype,'_countOfRows',{get(){\n    return this.text.split('\\n').length-1\n}})\nObject.defineProperty(Cursor.prototype,'_countOfCols',{get(){\n    return this.text?this.text.split('\\n')[this.r].length:0\n}})\nObject.defineProperty(Cursor.prototype,'_exotic',{get(){\n    let c=Object.create(this)\n    Object.defineProperty(c,'_x',{set:val=>this._x=val,get:()=>this._x})\n    Object.defineProperty(c,'_y',{set:val=>this._y=val,get:()=>this._y})\n    return c\n}})\nObject.defineProperty(Cursor.prototype,'r',{set(val){\n    this._y=val\n},get(){\n    return Math.min(this._countOfRows-1,Math.max(0,this._y))\n}})\nObject.defineProperty(Cursor.prototype,'c',{set(val){\n    this._x=val\n},get(){\n    return Math.min(availableCols(this)-1,Math.max(0,this._x))\n}})\nfunction availableCols(c){\n    if(\n        c.mode=='normal'||\n        c.mode=='cmdline'\n    )\n        return c._countOfCols\n    if(\n        c.mode=='visual'||\n        c.mode=='insert'\n    )\n        return c._countOfCols+1\n}\nCursor.prototype.line=function(n){\n    return this.text.split('\\n').slice(0,n).join('').length+n\n}\n// end 0\n// start 1\nCursor.prototype.moveLeft=function(){\n    this._x=Math.max(0,this.c-1)\n}\nCursor.prototype.moveRight=function(){\n    this._x=Math.min(availableCols(this)-1,this.c+1)\n}\nCursor.prototype.moveUp=function(){\n    this._y=Math.max(0,this._y-1)\n}\nCursor.prototype.moveDown=function(){\n    this._y=Math.min(this._countOfRows-1,this._y+1)\n}\n// end 1\n// start 1a\nObject.defineProperty(Cursor.prototype,'onChar',{get(){\n    return 0<=this.c\n}})\nObject.defineProperty(Cursor.prototype,'abs',{get(){\n    return(0<=this.r?this.line(this.r):0)+(0<=this.c?this.c:0)\n}})\n// end 1a\n// start 1b\nCursor.prototype.moveTo=function(n){\n    this._y=this.text.substring(0,n).split('\\n').length-1\n    this._x=n-(\n        this.text.split('\\n').slice(0,this.r).join('').length+this.r\n    )\n}\n// end 1b\n// start 1c\nObject.defineProperty(Cursor.prototype,'lineStart',{get(){\n    return this.text.substring(0,this.abs).lastIndexOf('\\n')+1\n}})\nObject.defineProperty(Cursor.prototype,'lineEnd',{get(){\n    let a=this.abs\n    return a+this.text.substring(a).indexOf('\\n')+1\n}})\n// end 1c\n// start 2\nCursor.prototype.moveToEOL=function(){\n    this.moveTo(this.lineEnd-1)\n}\n// end 2\nCursor\n","Vim/createCursor.js":"(async()=>{\n    let\n        VimCursor=await module.shareImport('createCursor/VimCursor.js')\n    function createCursor(vim){\n        let cursor=new VimCursor,trueCursor=cursor._exotic\n        Object.defineProperty(cursor,'text',{configurable:true,get(){\n            return vim._text\n        }})\n        Object.defineProperty(cursor,'mode',{get(){\n            return vim._mode\n        }})\n        Object.defineProperty(trueCursor,'text',{get(){\n            return vim._trueText\n        }})\n        return[cursor,trueCursor]\n    }\n    return createCursor\n})()\n","Vim/defaultOptions.js":"({\n    expandtab:  false,\n    list:       false,\n    number:     false,\n    shiftwidth: 8,\n    tabstop:    8,\n})\n","Vim/loadBase/lc.js":"(s=>{\n    let\n        l=s.split('\\n').length-1,\n        c=s.length\n    return `${l}L, ${c}C`\n})\n","Vim/loadBase/prototype._edit.js":"module.import('lc.js').then(lc=>{\n    return function(p){\n        let read=this.read(p)\n        this._registers['%']=p\n        if(read==undefined){\n            this.text=''\n            return `\"${p}\" [New File]`\n        }else{\n            this.text=read\n            return `\"${p}\" ${lc(read)}`\n        }\n    }\n})\n","Vim/loadBase/prototype._mode/Cursor.js":"function Cursor(set,get){\n    this._position=0\n    Object.defineProperty(this,'string',{set,get})\n}\nObject.defineProperty(Cursor.prototype,'backspace',{get(){\n    if(this._position<1)\n        return\n    this.string=\n        this.string.substring(0,this._position-1)+\n        this.string.substring(this._position)\n    this._position--\n}})\nObject.defineProperty(Cursor.prototype,'delete',{get(){\n    if(this._position==this.string.length)\n        return\n    this.string=\n        this.string.substring(0,this._position)+\n        this.string.substring(this._position+1)\n}})\nObject.defineProperty(Cursor.prototype,'end',{get(){\n    this._position=this.string.length\n}})\nObject.defineProperty(Cursor.prototype,'home',{get(){\n    this._position=0\n}})\nObject.defineProperty(Cursor.prototype,'position',{set(v){\n    this._position=Math.min(this.string.length,Math.max(0,v))\n},get(){\n    return this._position\n}})\nCursor\n","Vim/loadBase/prototype._mode.js":"(async()=>{\n    let Cursor=await module.shareImport('prototype._mode/Cursor.js')\n    return{\n        set(val){\n            this._viewChanged.mode=true\n            this._modeData={}\n            let abs=this._cursor.abs\n            if(val=='insert'){\n                this._welcomeText=undefined\n            }\n            if(val=='visual'){\n                this._modeData.cursor=this._cursor.abs\n                this._welcomeText=undefined\n            }\n            if(val=='cmdline'){\n                this._modeData.inputBuffer=''\n                this._modeData.cursor=new Cursor(v=>\n                    this._modeData.inputBuffer=v\n                ,()=>\n                    this._modeData.inputBuffer\n                )\n            }\n            this._values.mode=val\n            if(abs)\n                this._cursor.moveTo(abs)\n        },get(){\n            return this._values.mode\n        }\n    }\n})()\n","Vim/loadBase/prototype._text.js":"({\n    set(val){\n        let set=val=>{\n            if(typeof val=='string'){\n                this._values.text=val\n            }else if(typeof val=='object'){\n                let txt=this._values.text\n                if(val.function=='insert')\n                    this._values.text=\n                        txt.substring(0,val.position)+\n                        val.string+\n                        txt.substring(val.position)\n                else if(val.function=='delete')\n                    this._values.text=\n                        txt.substring(0,val.start)+\n                        txt.substring(val.end)\n                else if(val.function=='replace'){\n                    this._text={\n                        function:'delete',\n                        start:val.start,\n                        end:val.end,\n                    }\n                    this._text={\n                        function:'insert',\n                        position:val.start,\n                        string:val.string,\n                    }\n                    return\n                }\n            }\n            this._viewChanged.text=this._viewChanged.text||[]\n            this._viewChanged.text.push(val)\n        }\n        set(val)\n        if(/[^\\n]$/.test(this._values.text))set({\n            function:'insert',\n            position:this._values.text.length,\n            string:'\\n',\n        })\n    },get(){\n        return this._values.text\n    }\n})\n","Vim/loadBase/prototype._welcomeText.js":"(`\\\n                     Web Vim\n\nThanks Bram Moolenaar et al. for the original Vim!\n\n             type :q<Enter> to exit            \n`)\n","Vim/loadBase/prototype._write.js":"module.import('lc.js').then(lc=>{\n    return function(){\n        let p=this._registers['%']\n        this.write&&this.write(p)\n        return `${p?`\"${p}\"`:'[Event-Only]'} ${lc(this._text)} written`\n    }\n})\n","Vim/loadBase.js":"let proto=Promise.all([\n    module.shareImport('loadBase/prototype._welcomeText.js'),\n    module.shareImport('loadBase/prototype._write.js'),\n    module.shareImport('loadBase/prototype._edit.js'),\n    module.shareImport('loadBase/prototype._mode.js'),\n    module.shareImport('loadBase/prototype._text.js'),\n])\n;(async()=>{\n    proto=await proto\n    return o=>{\n        o._quit=function(){\n            this.emit('quit')\n        }\n        Object.defineProperty(o,'_trueText',{set(val){\n            if(this._text=='')\n                this._text='\\n'\n            this._text=val\n        },get(){\n            return this._values.text||'\\n'\n        }})\n        o._ui=function(){\n            this._uis.forEach(ui=>\n                ui._updateByVim(this._viewChanged)\n            )\n            this._viewChanged={}\n        }\n        o._read=function(path){\n            return this.read&&this.read(path)\n        }\n        Object.defineProperty(o,'_mode',proto[3])\n        Object.defineProperty(o,'_text',proto[4])\n        o._write=proto[1]\n        o._edit=proto[2]\n        o._welcomeText=proto[0]\n        o._setOption=function(key,value){\n            this._options[key]=value\n            this._viewChanged.options=this._viewChanged.options||{}\n            this._viewChanged.options[key]=null\n        }\n        o._setRegister=function(key,value){\n            this._registers[key]=value\n            if(key=='+')\n                this.copy&&this.copy(value.string)\n        }\n        Object.defineProperty(o,'_mainUi',{get(){\n            if(!this._values._mainUi){\n                this._values._mainUi=this.ui\n                this._values._mainUi.width=80\n                this._values._mainUi.height=24\n            }\n            return this._values._mainUi\n        }})\n    }\n})()\n","Vim/loadSyntacticSugar.js":"(o=>{\n    Object.defineProperty(o,'node',{get(){\n        return this._mainUi.node\n    }})\n    Object.defineProperty(o,'height',{set(val){\n        this._mainUi.height=val\n    }})\n    Object.defineProperty(o,'width',{set(val){\n        this._mainUi.width=val\n    }})\n    Object.defineProperty(o,'pollute',{get(){\n        this.polluteStyle\n        this.polluteCopy\n    }})\n    Object.defineProperty(o,'polluteStyle',{get(){\n        document.head.appendChild(this.style)\n        this.once('quit',()=>{\n            document.head.removeChild(this.style)\n        })\n    }})\n    Object.defineProperty(o,'polluteCopy',{get(){\n        this.copy=s=>{\n            let n=document.createElement('textarea')\n            n.value=s\n            n.style.position='fixed'\n            let e=document.activeElement\n            document.body.appendChild(n)\n            n.select()\n            document.execCommand('copy',true,null)\n            document.body.removeChild(n)\n            if(e)\n                e.focus()\n        }\n    }})\n})\n","Vim/loadUserInterface/input/cmdline.js":"let shortcut={\n    nu:'number',\n}\nfunction main(vim,val){\n    let enter=false\n    if(typeof val=='object'){\n        if(val.key=='ArrowLeft')\n            vim._modeData.cursor.position--\n        else if(val.key=='ArrowRight')\n            vim._modeData.cursor.position++\n        else if(val.key=='Backspace')\n            vim._modeData.cursor.backspace\n        else if(val.key=='Delete')\n            vim._modeData.cursor.delete\n        else if(val.key=='End')\n            vim._modeData.cursor.end\n        else if(val.key=='Enter')\n            enter=true\n        else if(\n            val.key=='Escape'||\n            val.ctrlKey&&val.key=='c'||\n            val.ctrlKey&&val.key=='['\n        )\n            return vim._mode='normal'\n        else if(val.key=='Home')\n            vim._modeData.cursor.home\n    }else if(typeof val=='string'){\n        vim._modeData.inputBuffer=\n            vim._modeData.inputBuffer.substring(\n                0,vim._modeData.cursor.position\n            )+\n            val+\n            vim._modeData.inputBuffer.substring(\n                vim._modeData.cursor.position\n            )\n        vim._modeData.cursor.position+=val.length\n    }\n    let cmd=vim._modeData.inputBuffer\n    if(!cmd)\n        return vim._mode='normal'\n    if(!enter)\n        return\n    let status\n    if(cmd[0]==':'){\n        cmd=cmd.substring(1)\n        let\n            setPattern=/^set?(.*)/,\n            editPattern=/^e(?:dit)?(.*)/\n        if(setPattern.test(cmd)){\n            status=set(vim,cmd.match(setPattern)[1])\n        }else if(editPattern.test(cmd)){\n            status=edit(vim,cmd.match(editPattern)[1])\n        }else if(/^q(?:uit)?$/.test(cmd)){\n            vim._quit()\n        }else if(/^wq$/.test(cmd)){\n            vim._write()\n            vim._quit()\n        }else if(/^w(?:rite)?$/.test(cmd)){\n            status=vim._write()\n        }\n    }else if(cmd[0]=='/'){\n    }\n    vim._mode='normal'\n    if(status)\n        vim._modeData.status=status\n}\nfunction edit(vim,cmd){\n    let argumentPattern=/ (.*)/\n    if(argumentPattern.test(cmd)){\n        cmd=cmd.match(argumentPattern)[1]\n        return vim._edit(cmd)\n    }\n}\nfunction set(vim,cmd){\n    let argumentPattern=/ (.*)/\n    if(argumentPattern.test(cmd)){\n        cmd=cmd.match(argumentPattern)[1]\n        let\n            showValuePattern=   /(.*)\\?$/,\n            argsPattern=        /(.*)[=:](.*)/,\n            noPattern=          /^no(.*)/,\n            show=       false,\n            toSet=      false,\n            option,\n            value\n        if(showValuePattern.test(cmd)){\n            show=true\n            option=cmd.match(showValuePattern)[1]\n        }else if(argsPattern.test(cmd)){\n            toSet=true\n            option=cmd.match(argsPattern)[1]\n            value=parseInt(cmd.match(argsPattern)[2],10)\n        }else{\n            toSet=true\n            if(noPattern.test(cmd)){\n                option=cmd.match(noPattern)[1]\n                value=false\n            }else{\n                option=cmd\n                value=true\n            }\n        }\n        if(option in shortcut)\n            option=shortcut[option]\n        if(toSet){\n            if(option in vim._options)\n                vim._setOption(option,value)\n        }else if(show){\n            let v=vim._options[option]\n            let res=`${v==false?'no':'  '}${option}`\n            if(typeof v=='number')\n                res+=`=${v}`\n            return res\n        }\n    }\n}\n((vim,val)=>{\n    let r=main(vim,val)\n    vim._ui()\n    return r\n})\n","Vim/loadUserInterface/input/insert.js":"function main(vim,val){\n    if(typeof val=='object')\n        val=object(vim,val)\n    if(typeof val=='string'){\n        let abs=vim._trueCursor.abs\n        val=val.replace(/\\r/,'\\n')\n        vim._trueText={\n            function:'insert',\n            position:abs,\n            string:val,\n        }\n        vim._trueCursor.moveTo(abs+val.length)\n    }\n}\nfunction object(vim,val){\n    if(\n        val.ctrlKey&&val.key=='c'||\n        val.ctrlKey&&val.key=='['\n    )\n        val={key:'Escape'}\n    switch(val.key){\n        case 'ArrowDown':\n            vim._trueCursor.moveDown()\n            return\n        case 'ArrowLeft':\n            vim._trueCursor.moveLeft()\n            return\n        case 'ArrowRight':\n            vim._trueCursor.moveRight()\n            return\n        case 'ArrowUp':\n            vim._trueCursor.moveUp()\n            return\n        case 'Backspace':\n            {\n                let abs=vim._trueCursor.abs\n                if(abs==0)\n                    return\n                vim._text={\n                    function:'delete',\n                    start:abs-1,\n                    end:abs,\n                }\n                vim._trueCursor.moveTo(abs-1)\n            }\n            return\n        case 'Delete':\n            {\n                let\n                    txt=vim._trueText,\n                    abs=vim._trueCursor.abs\n                if(abs+1==txt.length)\n                    return\n                vim._text={\n                    function:'delete',\n                    start:abs,\n                    end:abs+1,\n                }\n                vim._trueCursor.moveTo(abs)\n            }\n            return\n        case 'Enter':\n            return '\\r'\n        case 'Escape':\n            vim._undoBranchManager.push(vim._text)\n            vim._mode='normal'\n            return\n        case 'Tab':\n            {\n                let abs=vim._trueCursor.abs\n                vim._text={\n                    function:'insert',\n                    position:abs,\n                    string:'\\t',\n                }\n                vim._trueCursor.moveTo(abs+1)\n            }\n            return\n    }\n}\n;((vim,val)=>{\n    let r=main(vim,val)\n    vim._ui()\n    return r\n})\n","Vim/loadUserInterface/input/normal/ascii.js":"({\n    bs:     String.fromCharCode(0x08),\n    cr:     String.fromCharCode(0x0d),\n    esc:    String.fromCharCode(0x1b),\n    del:    String.fromCharCode(0x7f),\n})\n","Vim/loadUserInterface/input/normal/commands/letters.js":"(async()=>{\n    let docs=await module.repository.docs\n    function a(vim,cmd,arg){\n        return{function:'a'}\n    }\n    function d(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        if(cmd=='d')\n            return{\n                function:'dd',\n                count:arg||1,\n                register:'\"',\n            }\n    }\n    function g(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        if(cmd=='g')\n            return{\n                function:'gg',\n                count:arg,\n            }\n    }\n    function h(vim,cmd,arg){\n        return{\n            function:'h',\n            count:arg,\n        }\n    }\n    function i(vim,cmd,arg){\n        vim._mode='insert'\n        return docs.ac\n    }\n    function j(vim,cmd,arg){\n        return{\n            function:'j',\n            count:arg,\n        }\n    }\n    function k(vim,cmd,arg){\n        return{\n            function:'k',\n            count:arg,\n        }\n    }\n    function l(vim,cmd,arg){\n        return{\n            function:'l',\n            count:arg,\n        }\n    }\n    function n(vim,cmd,arg){\n        //vim.gotoNextMatch()\n        return docs.ac\n    }\n    function o(vim,cmd,arg){\n        return{function:'o'}\n    }\n    function p(vim,cmd,arg){\n        return{\n            function:'p',\n            count:arg||1,\n            register:'\"',\n        }\n    }\n    function r(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        if(vim._text){\n            let c=vim._trueCursor.abs\n            vim._text=vim._text.substring(0,c)+cmd+vim._text.substring(c+1)\n        }\n        return docs.acc\n    }\n    function u(vim,cmd,arg){\n        let s=vim._undoBranchManager.gotoPrevious()\n        if(s!=undefined)\n            vim._text=s\n        return docs.ac\n    }\n    function v(vim,cmd,arg){\n        let c=vim._trueCursor.abs\n        vim._mode='visual'\n        vim._trueCursor.moveTo(c)\n        return docs.ac\n    }\n    function x(vim,cmd,arg){\n        return{\n            function:'x',\n            count:arg||1,\n            register:'\"'\n        }\n    }\n    function y(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        if(cmd=='y')\n            return{\n                function:'yy',\n                count:arg||1,\n                register:'\"',\n            }\n    }\n    function A(vim){\n        vim._mode='insert'\n        vim._trueCursor.moveToEOL()\n        return docs.ac\n    }\n    function D(vim,cmd,arg){\n        return{\n            function:'D',\n            count:arg||1,\n            register:'\"',\n        }\n    }\n    function G(vim,cmd,arg){\n        return{\n            function:'G',\n            count:arg,\n        }\n    }\n    function I(vim,cmd,arg){\n        vim._mode='insert'\n        vim._trueCursor.moveTo(vim._trueCursor.lineStart)\n        return docs.ac\n    }\n    function O(vim,cmd,arg){\n        return{function:'O'}\n    }\n    function P(vim,cmd,arg){\n        return{\n            function:'P',\n            count:arg||1,\n            register:'\"',\n        }\n    }\n    function X(vim,cmd,arg){\n        return{\n            function:'X',\n            count:arg||1,\n            register:'\"'\n        }\n    }\n    return({A,D,G,I,O,P,X,a,d,g,h,i,j,k,l,n,o,p,r,u,v,x,y})\n})()\n","Vim/loadUserInterface/input/normal/commands.js":"Promise.all([\n    module.shareImport('commands/letters.js'),\n    module.repository.shift,\n]).then(async modules=>{\n    let\n        letters=        modules[0],\n        shift=          modules[1],\n        docs=           await module.repository.docs\n    function lt(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        if(cmd=='<'){\n            arg||(arg=1)\n            shift.left(vim,vim._trueCursor.r,vim._trueCursor.r+arg)\n            return docs.acc\n        }\n    }\n    function gt(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        if(cmd=='>'){\n            arg||(arg=1)\n            shift.right(vim,vim._trueCursor.r,vim._trueCursor.r+arg)\n            return docs.acc\n        }\n    }\n    function dot(vim,cmd,arg){\n        return docs.ac\n    }\n    function colon(vim){\n        vim._mode='cmdline'\n        vim._modeData.inputBuffer=':'\n        vim._modeData.cursor.position=1\n        return docs.a\n    }\n    function slash(vim){\n        vim._mode='cmdline'\n        vim._modeData.inputBuffer='/'\n        vim._modeData.cursor.position=1\n        return docs.a\n    }\n    function caret(vim){\n        vim._trueCursor.moveTo(vim._trueCursor.lineStart)\n        return docs.ac\n    }\n    function dollarSign(vim){\n        vim._trueCursor.moveTo(Math.max(\n            vim._trueCursor.lineStart,\n            vim._trueCursor.lineEnd-2\n        ))\n        return docs.ac\n    }\n    function ctrl(vim,cmd){\n        if(cmd=='')\n            return docs.a\n        if(cmd=='r'){\n            if(vim._undoBranchManager.current.next!=undefined){\n                vim._undoBranchManager.current=\n                    vim._undoBranchManager.current.next\n                vim._text=vim._undoBranchManager.current.text\n            }\n            return docs.ac\n        }\n    }\n    function quotationMark(vim,cmd,arg){\n        if(cmd=='')\n            return docs.a\n        let register=cmd[0]\n        cmd=cmd.substring(1)\n        if(cmd=='')\n            return docs.a\n        let count=arg||1\n        if(cmd=='P')\n            return{function:'P',register,count}\n        if(cmd=='p')\n            return{function:'p',register,count}\n        if(cmd=='d'||cmd=='y')\n            return docs.a\n        if(cmd=='dd')\n            return{function:'dd',register,count}\n        if(cmd=='yy')\n            return{function:'yy',register,count}\n    }\n    let commands={\n        A:letters.A,\n        D:letters.D,\n        G:letters.G,\n        I:letters.I,\n        O:letters.O,\n        P:letters.P,\n        X:letters.X,\n        a:letters.a,\n        d:letters.d,\n        g:letters.g,\n        h:letters.h,\n        i:letters.i,\n        j:letters.j,\n        k:letters.k,\n        l:letters.l,\n        n:letters.n,\n        o:letters.o,\n        p:letters.p,\n        r:letters.r,\n        u:letters.u,\n        v:letters.v,\n        x:letters.x,\n        y:letters.y,\n        '<':lt,\n        '>':gt,\n        '.':dot,\n        ':':colon,\n        '/':slash,\n        '^':caret,\n        '$':dollarSign,\n        '\"':quotationMark,\n    }\n    commands[String.fromCharCode(17)]=ctrl\n    return commands\n})\n","Vim/loadUserInterface/input/normal/docs.js":"({\n    a:{\n        acceptable:true\n    },\n    ac:{\n        acceptable:true,\n        complete:true,\n    },\n    acc:{\n        acceptable:true,\n        complete:true,\n        changed:true,\n    }\n})\n","Vim/loadUserInterface/input/normal/functions/functions.js":"(async()=>{\n    function yank(vim,r,m,s){\n        vim._setRegister(r,{mode:m,string:s})\n    }\n    function put(vim,c,s){\n        vim._trueText={\n            function:'insert',\n            position:c,\n            string:s,\n        }\n    }\n    function putCharacterwise(vim,c,s){\n        put(vim,c,s)\n        vim._trueCursor.moveTo(c+s.length-1)\n    }\n    function putLinewise(vim,c,s){\n        put(vim,c,s)\n        vim._trueCursor.moveTo(c)\n    }\n    function delete_(a,b){\n        vim._trueText={\n            function:'delete',\n            start:a,\n            end:b,\n        }\n    }\n    function deleteCharacterwise(vim,r,a,b){\n        yank(vim,r,'string',vim._trueText.substring(a,b))\n        delete_(a,b)\n        vim._trueCursor.moveTo(a)\n    }\n    function deleteLinewise(vim,r,a,b){\n        yank(vim,r,'line',vim._trueText.substring(a,b))\n        delete_(a,b)\n    }\n    return{\n        yank,\n        putCharacterwise,\n        putLinewise,\n        deleteCharacterwise,\n        deleteLinewise,\n    }\n})()\n\n","Vim/loadUserInterface/input/normal/functions/motions.js":"(async()=>{\n    let docs=await module.repository.docs\n    function h(vim,doc){\n        let count=doc.count||1\n        while(count--)\n            vim._trueCursor.moveLeft()\n        return docs.ac\n    }\n    function j(vim,doc){\n        let count=doc.count||1\n        while(count--)\n            vim._trueCursor.moveDown()\n        return docs.ac\n    }\n    function k(vim,doc){\n        let count=doc.count||1\n        while(count--)\n            vim._trueCursor.moveUp()\n        return docs.ac\n    }\n    function l(vim,doc){\n        let count=doc.count||1\n        while(count--)\n            vim._trueCursor.moveRight()\n        return docs.ac\n    }\n    return({h,j,k,l})\n})()\n","Vim/loadUserInterface/input/normal/functions.js":"let\n    functions=  module.shareImport('functions/functions.js'),\n    motions=    module.shareImport('functions/motions.js')\n;(async()=>{\n    let docs=await module.repository.docs\n    functions=  await functions\n    motions=    await motions\n    function gotoLine(vim,n){\n        vim._trueCursor.moveTo(vim._trueCursor.line(n))\n    }\n    function D(vim,doc){\n        functions.deleteCharacterwise(\n            vim,\n            doc.register,\n            vim._trueCursor.abs,\n            vim._trueCursor.lineEnd-1\n        )\n        if(vim._trueCursor.abs)\n            vim._trueCursor.moveTo(vim._trueCursor.abs)\n        return docs.acc\n    }\n    function G(vim,doc){\n        gotoLine(vim,Math.min(\n            vim._trueCursor._countOfRows,\n            doc.count||vim._trueCursor._countOfRows\n        )-1)\n        return docs.ac\n    }\n    function O(vim,doc){\n        functions.putLinewise(vim,vim._trueCursor.lineStart,'\\n')\n        vim._mode='insert'\n        return docs.acc\n    }\n    function P(vim,doc){\n        let reg=vim._registers[doc.register]\n        if(!reg)\n            return docs.ac\n        let s=reg.string.repeat(doc.count)\n        if(reg.mode=='string')\n            functions.putCharacterwise(vim,vim._trueCursor.abs,s)\n        else if(reg.mode=='line')\n            functions.putLinewise(vim,vim._trueCursor.lineStart,s)\n        return docs.acc\n    }\n    function X(vim,doc){\n        let\n            abs=vim._trueCursor.abs,\n            ls=vim._trueCursor.lineStart,\n            count=Math.min(abs-ls,Math.max(0,doc.count))\n        functions.deleteCharacterwise(vim,doc.register,abs-count,abs)\n        return docs.acc\n    }\n    function a(vim,doc){\n        vim._mode='insert'\n        vim._trueCursor.moveRight()\n        return docs.ac\n    }\n    function dd(vim,doc){\n        let c=vim._cursor\n        if(c.r<0)\n            return docs.ac\n        let count=Math.min(c._countOfRows-c.r,doc.count)\n        functions.deleteLinewise(\n            vim,\n            doc.register,\n            c.line(c.r),\n            c.line(c.r+count)\n        )\n        c.moveTo(c.lineStart)\n        return docs.acc\n    }\n    function gg(vim,doc){\n        gotoLine(vim,Math.min(vim._trueCursor._countOfRows,doc.count||1)-1)\n        return docs.ac\n    }\n    function o(vim,doc){\n        functions.putLinewise(vim,vim._trueCursor.lineEnd,'\\n')\n        vim._mode='insert'\n        return docs.acc\n    }\n    function p(vim,doc){\n        let reg=vim._registers[doc.register]\n        if(!reg)\n            return docs.ac\n        let s=reg.string.repeat(doc.count)\n        if(reg.mode=='string')\n            functions.putCharacterwise(vim,vim._trueCursor.abs+1,s)\n        else if(reg.mode=='line')\n            functions.putLinewise(vim,vim._trueCursor.lineEnd,s)\n        return docs.acc\n    }\n    function yy(vim,doc){\n        let c=vim._cursor\n        if(c.r<0)\n            return docs.ac\n        let arg=doc.count\n        arg=Math.min(c._countOfRows-c.r,arg)\n        let\n            a=c.line(c.r),\n            b=c.line(c.r+arg)\n        functions.yank(vim,doc.register,'line',c.substring(a,b))\n        return docs.ac\n    }\n    function x(vim,doc){\n        let\n            abs=vim._trueCursor.abs,\n            le=vim._trueCursor.lineEnd,\n            count=Math.min(le-1-abs,Math.max(0,doc.count))\n        functions.deleteCharacterwise(vim,doc.register,abs,abs+count)\n        return docs.acc\n    }\n    return{\n        D,\n        G,\n        O,\n        P,\n        X,\n        a,\n        dd,\n        gg,\n        h:motions.h,\n        j:motions.j,\n        k:motions.k,\n        l:motions.l,\n        o,\n        p,\n        yy,\n        x,\n    }\n})()\n","Vim/loadUserInterface/input/normal.js":"module.repository.docs=module.shareImport('normal/docs.js')\nlet functions=module.shareImport('normal/functions.js')\n;(async modules=>{\n    let[\n        commands,\n        ascii,\n    ]=await Promise.all([\n        module.shareImport('normal/commands.js'),\n        module.shareImport('normal/ascii.js'),\n    ])\n    functions=await functions\n    return(vim,val)=>{\n        if(typeof val=='object')\n            val=object(vim,val)\n        if(!('command' in vim._modeData))\n            vim._modeData.command=''\n        vim._modeData.command+=val\n        let\n            cmd=vim._modeData.command,\n            arg\n        if(49<=cmd.charCodeAt(0)&&cmd.charCodeAt(0)<58){\n            arg=parseInt(cmd,10)\n            cmd=cmd.substring(arg.toString().length)\n        }\n        let res=tryCommand(vim,cmd,arg)||{}\n        if(res.function!=undefined&&res.function in functions)\n            res=functions[res.function](vim,res)\n        if(res.acceptable){\n            if(res.complete){\n                if(res.changed)\n                    vim._undoBranchManager.push(vim._text)\n                if(vim.mode=='normal')\n                    vim._modeData.command=''\n            }\n        }else{\n            vim._modeData.command=''\n        }\n        vim._ui()\n    }\n    function object(vim,val){\n        if(val.ctrlKey){\n            if(val.key=='r')\n                return String.fromCharCode(17)+'r'\n        }else switch(val.key){\n            case 'ArrowLeft':\n                return 'h'\n            case 'ArrowRight':\n                return 'l'\n            case 'ArrowDown':\n                return 'j'\n            case 'ArrowUp':\n                return 'k'\n            case 'Backspace':\n                return ascii.bs\n            case 'Enter':\n                return ascii.cr\n            case 'Delete':\n                return ascii.del\n        }\n        return''\n    }\n    function tryCommand(vim,cmd,arg){\n        if(cmd=='')\n            return{acceptable:true}\n        if(cmd[0] in commands)\n            return commands[cmd[0]](vim,cmd.substring(1),arg)\n    }\n})()\n","Vim/loadUserInterface/input/shift.js":"function shift(vim,s,e,count){\n    let cursor=Object.create(vim._trueCursor)\n    for(;s!=e;s++){\n        cursor.r=s\n        let\n            a=cursor.lineStart,\n            b=cursor.lineEnd,\n            m=vim._trueText.substring(a,b).match(/^([\\t ]*)([\\S\\s]*)/)\n        vim._text={\n            function:'replace',\n            start:a,\n            end:b,\n            string:padding(vim._options,count(m[1]))+m[2],\n        }\n    }\n}\nfunction padding(o,n){\n    let\n        a=Math.floor(n/o.tabstop),\n        b=n-a*o.tabstop\n    return(\n        o.expandtab?' '.repeat(o.tabstop):'\\t'\n    ).repeat(a)+' '.repeat(b)\n}\nfunction countPadding(vim,s){\n    return count(s,'\\t')*vim._options.tabstop+count(s,' ')\n    function count(s,c){\n        return s.split(c).length-1\n    }\n}\nfunction left(vim,s,e){\n    shift(vim,s,e,m=>Math.max(0,countPadding(vim,m)-vim._options.shiftwidth))\n}\nfunction right(vim,s,e){\n    shift(vim,s,e,m=>countPadding(vim,m)+vim._options.shiftwidth)\n}\n({\n    left,\n    right\n})\n","Vim/loadUserInterface/input/visual.js":"(async()=>{\n    let\n        visualRange=await module.repository.visualRange,\n        shift=await module.repository.shift\n    function main(vim,val){\n        if(typeof val=='string'){\n            if(val=='d'){\n                let\n                    r=visualRange(vim),\n                    b=vim._text.substring(r.s,r.e)\n                vim._text={\n                    function:'delete',\n                    start:r.s,\n                    end:r.e,\n                }\n                vim._registers['\"']={mode:'string',string:b}\n                vim._trueCursor.moveTo(r.s)\n                vim._mode='normal'\n                return\n            }\n            if(val=='h')\n                return vim._trueCursor.moveLeft()\n            if(val=='j')\n                return vim._trueCursor.moveDown()\n            if(val=='k')\n                return vim._trueCursor.moveUp()\n            if(val=='l')\n                return vim._trueCursor.moveRight()\n            if(val=='y'){\n                let r=visualRange(vim)\n                vim._registers['\"']={\n                    mode:'string',\n                    string:vim._text.substring(r.s,r.e),\n                }\n                vim._trueCursor.moveTo(r.s)\n                vim._mode='normal'\n                return\n            }\n            if(val=='<'){\n                let r=visualRange(vim)\n                let cursor=Object.create(vim._trueCursor)\n                cursor.moveTo(r.s)\n                let s=cursor.r\n                cursor.moveTo(r.e)\n                let e=cursor.r\n                shift.left(vim,s,e+1)\n                vim._mode='normal'\n                return\n            }\n            if(val=='>'){\n                let r=visualRange(vim)\n                let cursor=Object.create(vim._trueCursor)\n                cursor.moveTo(r.s)\n                let s=cursor.r\n                cursor.moveTo(r.e)\n                let e=cursor.r\n                shift.right(vim,s,e+1)\n                vim._mode='normal'\n                return\n            }\n        }else if(typeof val=='object'){\n            if(\n                val.key=='Escape'||\n                val.ctrlKey&&val.key=='c'||\n                val.ctrlKey&&val.key=='['\n            )\n                return vim._mode='normal'\n        }\n    }\n    return(vim,val)=>{\n        main(vim,val)\n        vim._ui()\n    }\n})()\n","Vim/loadUserInterface/input.js":"module.repository.shift=module.shareImport('input/shift.js')\nPromise.all([\n    module.shareImport('input/normal.js'),\n    module.shareImport('input/insert.js'),\n    module.shareImport('input/visual.js'),\n    module.shareImport('input/cmdline.js'),\n]).then(modules=>{\n    let\n        modes={\n            normal:     modules[0],\n            insert:     modules[1],\n            visual:     modules[2],\n            cmdline:    modules[3],\n        }\n    return{set(val){\n        modes[this.mode](this,val)\n    }}\n})\n","Vim/loadUserInterface/ui/GreedyText/wrapLine.js":"let\n    lfDoc={\n        child:'$',\n        class:'color4i',\n    }\nfunction substring(list,s,start,end){\n    let a=[]\n    for(;start!=end;start++){\n        let c=s[start]\n        a.push(c=='\\n'?list?Object.create(lfDoc):'\\n':c)\n    }\n    return a\n}\n;(async modules=>{\n    let stringWidth=await module.repository.stringWidth\n    function width(c){\n        return c=='\\n'?1:stringWidth(c)\n    }\n    function wrapLine(list,l,targetWidth){\n        let rows=[]\n        for(let i=0;i<l.length;){\n            let start=i,end=calcEnd(i,l,targetWidth)\n            rows.push({\n                start,\n                end,\n                string:substring(list,l,start,end)\n            })\n            i=end\n        }\n        return rows\n    }\n    function calcEnd(i,l,targetWidth){\n        for(\n            let rowWidth=0,w;\n            i<l.length&&rowWidth+(w=width(l[i]))<=targetWidth;\n            rowWidth+=w,i++\n        );\n        return i\n    }\n    return wrapLine\n})()\n","Vim/loadUserInterface/ui/GreedyText.js":"function GreedyText(){\n    this._options={}\n    this.lines=[]\n}\nGreedyText.prototype._char=function(n){\n    return this.lines.slice(0,n).map(v=>v.string.length+1).reduce(\n        (a,b)=>a+b,0\n    )\n}\nGreedyText.prototype._line=function(n){\n    let i=0,s=0\n    while(i<this.lines.length&&s+this.lines[i].string.length+1<=n)\n        s+=this.lines[i++].string.length+1\n    return i\n}\nObject.defineProperty(GreedyText.prototype,'countOfRows',{get(){\n    this.wrap()\n    return this.lines.map(l=>l.wrapped.rows.length).reduce((a,b)=>a+b,0)\n}})\nObject.defineProperty(GreedyText.prototype,'string',{get(){\n    return this.lines.map(l=>l.string+'\\n').join('')\n}})\nObject.defineProperty(GreedyText.prototype,'update',{set(val){\n    if(typeof val=='string'){\n        val=val.split('\\n')\n        val.pop()\n        this.lines=val.map(val=>new Line(val))\n    }else if(typeof val=='object'){\n        let removeAdd=(s,e,a)=>{\n            a=a.split('\\n')\n            a.pop()\n            a=a.map(v=>new Line(v))\n            a.unshift(s,e-s)\n            ;[].splice.apply(this.lines,a)\n        }\n        if(val.function=='insert'){\n            let l=this._line(val.position)\n            let p=val.position-this._char(l)\n            let s=(this.lines[l]?this.lines[l].string+'\\n':'')\n            s=s.substring(0,p)+val.string+s.substring(p)\n            removeAdd(l,l+1,s)\n        }else if(val.function=='delete'){\n            let sl=this._line(val.start),el=this._line(val.end)+2\n            let lc=this._char(sl)\n            let start=val.start-lc,end=val.end-lc\n            let s=this.lines.slice(sl,el).map(v=>v.string).join('\\n')+'\\n'\n            s=s.substring(0,start)+s.substring(end)\n            removeAdd(sl,el,s)\n        }\n    }\n}})\nObject.defineProperty(GreedyText.prototype,'width',{set(val){\n    if(this._width!=val)\n        this.lines.map(l=>{\n            delete l.rows\n        })\n    this._width=val\n},get(){\n    return this._width\n}})\nGreedyText.prototype.uiText=function(start,end){\n    let res=this.lines.map(l=>l.wrapped)\n    return start==undefined?res:cut(res)\n    function cut(res){\n        return res.map(l=>{\n            if(l.startRow+l.rows.length<=start||end<=l.startRow)\n                return\n            l.rows=l.rows.map((r,i)=>\n                inRange(l.startRow+i)&&r\n            ).filter(r=>r)\n            return l\n        }).filter(l=>l!=undefined)\n    }\n    function inRange(i){\n        return start<=i&&i<end\n    }\n}\nGreedyText.prototype.row=function(pos){\n    let res\n    this.wrap()\n    this.lines.map(l=>l.wrapped).map(l=>l.rows.map((r,i)=>{\n        if(l.start+r.start<=pos&&pos<l.start+r.end)\n            res=l.startRow+i\n    }))\n    return res\n}\nGreedyText.prototype.setOption=function(key,val){\n    this._options[key]=val\n    if(key=='list')\n        this.lines.map(l=>{\n            delete l.rows\n        })\n}\n/*\n    A line should not include EOL, since it has already been seperated\n    from the others.\n*/\nfunction Line(val){\n    this.string=val\n}\n;(async()=>{\n    let wrapLine=await module.shareImport('GreedyText/wrapLine.js')\n    GreedyText.prototype.wrap=function(){\n        let\n            charCount=0,\n            rowsCount=0\n        this.lines.map((l,j)=>{\n            let s=l.string+'\\n'\n            if(!l.rows)\n                l.rows=wrapLine(this._options.list,s,this.width||Infinity)\n            l.wrapped={\n                index:j,\n                start:charCount,\n                startRow:rowsCount,\n                rows:l.rows,\n            }\n            charCount+=s.length\n            rowsCount+=l.rows.length\n        })\n    }\n    return GreedyText\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/Cli/View/update.js":"function update(view){\n    if(view._width)\n        view.node.style.width=`${view._width*view._fontWidth}px`\n    if(view._height)\n        view.node.style.height=`${view._height*view._fontSize}px`\n    view._listeners.map(doc=>\n        doc.cli.removeListener('view',doc.listener)\n    )\n    view._listeners=[]\n    {\n        let a=dfs(view,view._cli,0,0)\n        reuseWrite(view,a,view._previousArray)\n        view._previousArray=a\n    }\n}\nfunction dfs(view,cli,dr,dc,o){\n    o||(o={})\n    cli._children.map(c=>{\n        let tr=dr+c.r,tc=dc+c.c\n        if(!(0<=tr&&tr<view._height&&0<=tc&&tc<view._width))\n            return\n        if(typeof c.child=='string'){\n            o[tr]||(o[tr]={})\n            o[tr][tc]=c\n        }else if(typeof c.child=='symbol')\n            view.symbols[c.child]={r:tr,c:tc}\n        else\n            dfs(view,c.child,tr,tc,o)\n    })\n    let listener=()=>update(view)\n    view._listeners.push({cli,listener})\n    cli.on('view',listener)\n    return o\n}\nfunction reuseWrite(view,a,b){\n    let o={}\n    for(let r in a)\n        for(let c in a[r])\n            if(r in b&&c in b[r]&&notEqual(a[r][c],b[r][c]))\n                write(view,a[r][c]||'',r,c)\n    inNotIn(a,b,(r,c)=>write(view,a[r][c],r,c))\n    inNotIn(b,a,(r,c)=>write(view,'',r,c))\n    return o\n    function set(r,c){\n        o[r]||(o[r]={})\n        o[r][c]=1\n    }\n    function notEqual(a,b){\n        if(a.child!=b.child)\n            return true\n        if(a.class!=b.class)\n            return true\n        if(a.style!=b.style)\n            return true\n        return false\n    }\n    function inNotIn(a,b,f){\n        for(let r in a)\n            for(let c in a[r])\n                if(!(r in b&&c in b[r]))\n                    f(r,c)\n    }\n}\nfunction write(view,doc,r,c){\n    let\n        div=getDiv(view,r,c),\n        textContent=doc.child\n    if(textContent=='\\n')\n        textContent=' '\n    div.className=doc.class||''\n    if(doc.style){\n        let span=document.createElement('span')\n        for(let i in doc.style)\n            span.style[i]=doc.style[i]\n        span.textContent=textContent\n        div.textContent=''\n        div.appendChild(span)\n    }else{\n        div.textContent=textContent\n    }\n    function getDiv(view,r,c){\n        if(!(r in view._divs))\n            view._divs[r]={}\n        if(!(c in view._divs[r])){\n            let div=document.createElement('div')\n            div.style.top=`${r*view._fontSize}px`\n            div.style.left=`${c*view._fontWidth}px`\n            view._divs[r][c]=div\n            view.node.appendChild(div)\n        }\n        return view._divs[r][c]\n    }\n}\nupdate\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/Cli/View.js":"(async()=>{\n    let[\n        update,\n        measureWidth,\n    ]=await Promise.all([\n        module.shareImport('View/update.js'),\n        module.repository.measureWidth,\n    ])\n    function View(cli){\n        this._cli=cli\n        this._fontSize=13\n        this._children=[]\n        this._divs={}\n        this._listeners=[]\n        this._previousArray={}\n        this._fontWidth=measureWidth(this._fontSize)\n        this.node=document.createElement('div')\n        this.node.className='cli'\n        this.symbols={}\n        update(this)\n    }\n    Object.defineProperty(View.prototype,'width',{set(val){\n        this._width=val\n        this.update\n    },get(){\n        return this._width\n    }})\n    Object.defineProperty(View.prototype,'height',{set(val){\n        this._height=val\n        this.update\n    },get(){\n        return this._height\n    }})\n    Object.defineProperty(View.prototype,'fontSize',{set(val){\n        this._fontSize=val\n        this._fontWidth=measureWidth(this._fontSize)\n        this.node.style.fontSize=`${this._fontSize}px`\n        this.update\n    }})\n    Object.defineProperty(View.prototype,'update',{set(val){\n        update(this)\n    }})\n    View.prototype.free=function(){\n        this._cli.removeListener('view',this._listener)\n    }\n    return View\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/Cli.js":"let\n    View=module.shareImport('Cli/View.js')\n;(async()=>{\n    let\n        EventEmmiter=   await module.repository.npm.events,\n        width=          await module.repository.stringWidth\n    View=await View\n    function Cli(){\n        EventEmmiter.call(this)\n        this._children=[]\n    }\n    Object.setPrototypeOf(Cli.prototype,EventEmmiter.prototype)\n    Object.defineProperty(Cli.prototype,'view',{get(){\n        let view=new View(this)\n        this.on('view',()=>view.update)\n        return view\n    }})\n    Cli.prototype.clear=function(){\n        this._flushed=false\n        this._children=[]\n    }\n    Cli.prototype.flush=function(){\n        if(this._flushed)\n            return\n        this.emit('view')\n        this._flushed=true\n    }\n    Cli.prototype.appendChild=function(child){\n        this._flushed=false\n        if(\n            typeof child=='string'||\n            child instanceof Cli\n        )\n            child={child}\n        if(!('r' in child))\n            child.r=0\n        if(!('c' in child))\n            child.c=0\n        if(typeof child.child=='string'){\n            let r=0,c=0\n            for(let i=0;i<child.child.length;i++){\n                let chr=child.child[i]\n                this._children.push({\n                    child:chr,\n                    r:child.r+r,\n                    c:child.c+c,\n                    class:child.class,\n                    style:child.style,\n                })\n                if(chr=='\\n'){\n                    r++\n                    c=0\n                }else{\n                    c+=width(chr)\n                }\n            }\n        }else\n            this._children.push(child)\n    }\n    return Cli\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/createCommandCli.js":"function update(ui,cli){\n    let vim=ui._vim\n    cli.clear()\n    if(vim.mode=='normal'){\n        cli.appendChild(vim._modeData.status!=undefined?\n            vim._modeData.status\n        :\n            ''\n        )\n    }else if(vim.mode=='insert'){\n        g('-- INSERT --')\n    }else if(vim.mode=='visual'){\n        g('-- VISUAL --')\n    }else if(vim.mode=='visual-block'){\n        g('-- VISUAL BLOCK --')\n    }\n    cli.appendChild({\n        child:cursor(\n            ui._vim._cursor.r,\n            ui._vim._cursor.c\n        ),\n        c:ui.width-18\n    })\n    cli.appendChild({\n        child:scroll(\n            ui._wrapMethodData._scroll,\n            ui._wrapMethodData.text.countOfRows,\n            ui.height\n        ),\n        c:ui.width-4\n    })\n    cli.flush()\n    function cursor(r,c){\n        return `${r+1},${c+1}`\n    }\n    function scroll(s,cr,h){\n        let\n            top=s==0,\n            bot=cr<=s+(h-1)\n        if(top&&bot)\n            return 'All'\n        if(top)\n            return 'Top'\n        if(bot)\n            return 'Bot'\n        let n=Math.floor(100*s/(cr-(h-1))).toString()\n        return`${' '.repeat(2-n.length)}${n}%`\n    }\n    function g(s){\n        cli.appendChild({child:s,style:{fontWeight:'bold'}})\n    }\n}\nfunction cmdlineUpdate(ui,cli){\n    let vim=ui._vim\n    let\n        text=vim._modeData.inputBuffer,\n        cursor=vim._modeData.cursor.position\n    cli.clear()\n    cli.appendChild(text)\n    cli.appendChild({\n        child:\n            text.substring(cursor,cursor+1)||' ',\n        c:cursor,\n        class:'cursor',\n    })\n    cli.flush()\n}\n;(async()=>{\n    let Cli=await module.repository.Cli\n    function CommandCli(ui){\n        this._ui=ui\n        this.cli=new Cli\n        this.update()\n    }\n    function createCommandCli(ui){\n        return new CommandCli(ui)\n    }\n    CommandCli.prototype.update=function(){\n        let\n            ui=this._ui,\n            cli=this.cli\n            vim=ui._vim\n        if(inNvii(vim.mode))\n            update(ui,cli)\n        else if(vim.mode=='cmdline')\n            cmdlineUpdate(ui,cli)\n        function inNvii(v){\n            return 0<=[\n                'normal',\n                'insert',\n                'visual',\n                'visual-block',\n            ].indexOf(v)\n        }\n    }\n    return createCommandCli\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/createInput.js":"(async()=>{\n    let measureWidth=await module.repository.measureWidth\n    return(ui=>{\n        let vim=ui._vim\n        let textarea=document.createElement('textarea')\n        textarea.className='input'\n        textarea.style.fontSize=`${ui._fontSize}px`\n        textarea.style.height=`${ui._fontSize+2}px`\n        let composing=false\n        textarea.addEventListener('blur',()=>{\n            vim._ui()\n        })\n        textarea.addEventListener('compositionstart',e=>{\n            composing=true\n        })\n        textarea.addEventListener('compositionend',e=>{\n            composing=false\n            f()\n        })\n        textarea.addEventListener('focus',()=>{\n            vim._ui()\n        })\n        textarea.addEventListener('input',()=>{\n            f()\n        })\n        textarea.addEventListener('keydown',e=>{\n            if(composing||!(\n                e.key=='ArrowLeft'||\n                e.key=='ArrowRight'||\n                e.key=='ArrowDown'||\n                e.key=='ArrowUp'||\n                e.key=='Backspace'||\n                e.key=='Delete'||\n                e.key=='End'||\n                e.key=='Enter'||\n                e.key=='Escape'||\n                e.key=='Home'||\n                e.key=='Tab'||\n                e.ctrlKey&&e.key=='c'||\n                e.ctrlKey&&e.key=='['||\n                e.ctrlKey&&e.key=='r'\n            ))\n                return\n            e.preventDefault()\n            e.stopPropagation()\n            vim.input=e\n        })\n        return textarea\n        function f(){\n            if(composing){\n                vim._ui()\n            }else{\n                vim.input=textarea.value\n                textarea.value=''\n            }\n            let width=measureWidth(ui._fontSize,textarea.value)\n            if(width)\n                width+=2\n            textarea.style.width=`${width}px`\n        }\n    })\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/createTextCli/build/createTextContentCli.js":"let highlightStyle={backgroundColor:'var(--middle-color)'}\n;(async()=>{\n    let\n        Cli=            await module.repository.Cli,\n        stringWidth=    await module.repository.stringWidth\n    function calcWidth(a){\n        let x=0\n        for(let i=0;i<a.length;i++){\n            let v=a[i]\n            x+=typeof v=='object'?stringWidth(v.child):stringWidth(v)\n        }\n        return x\n    }\n    function createTextContentCli(\n        text,\n        cursor,\n        showCursor,\n        highlightRange,\n        cursorSymbol,\n        width\n    ){\n        let cli=new Cli,rowsCount\n        {\n            let\n                currentRowsCount=0\n            text.map(l=>{\n                if(!l.rows.length)\n                    currentRowsCount++\n                l.rows.map(row=>{\n                    let rowStart=l.start+row.start\n                    for(\n                        let i=0,c=0;\n                        i<row.string.length;\n                        c+=calcWidth(row.string[i++])\n                    ){\n                        let o=row.string[i]\n                        if(typeof o=='string')\n                            o={child:o}\n                        else\n                            o={\n                                child:o.child,\n                                class:o.class,\n                                style:o.style,\n                            }\n                        o.r=currentRowsCount\n                        o.c=c\n                        if(\n                            highlightRange&&\n                            highlightRange.s<=rowStart+i&&\n                            rowStart+i<highlightRange.e\n                        )\n                            o.style=highlightStyle\n                        cli.appendChild(o)\n                    }\n                    currentRowsCount++\n                })\n            })\n            rowsCount=currentRowsCount\n        }\n        if(showCursor){\n            let c\n            c=cursor\n            c=cursorCli(text,{\n                r:c.r,\n                c:c.c==-1?0:c.c\n            },width)\n            if(c){\n                cli.appendChild(c)\n                cli.appendChild({\n                    child:cursorSymbol,\n                    r:c.r,\n                    c:c.c,\n                })\n            }\n        }\n        return{\n            textCli:cli,\n            rowsCount,\n        }\n    }\n    function cursorCli(text,vc,width){\n        let currentRowsCount=0\n        let clientCursor\n        text.map(l=>{\n            if(!l.rows.length)\n                currentRowsCount++\n            l.rows.map(row=>{\n                if(\n                    l.index==vc.r&&\n                    row.start<=vc.c&&vc.c<row.start+row.string.length\n                ){\n                    let viewC=width?vc.c-row.start:vc.c\n                    clientCursor={\n                        row:currentRowsCount,\n                        col:calcWidth(row.string.slice(0,viewC)),\n                        doc:row.string[viewC],\n                    }\n                }\n                currentRowsCount++\n            })\n        })\n        if(!clientCursor)\n            return\n        if(typeof clientCursor.doc!='object')\n            clientCursor.doc={child:clientCursor.doc}\n        clientCursor.doc=Object.create(clientCursor.doc)\n        clientCursor.doc.child=clientCursor.doc.child||' '\n        clientCursor.doc.r=clientCursor.row\n        clientCursor.doc.c=clientCursor.col\n        if(clientCursor.doc.class)\n            clientCursor.doc.class=`${clientCursor.doc.class} cursor`\n        else\n            clientCursor.doc.class='cursor'\n        return clientCursor.doc\n    }\n    return createTextContentCli\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/createTextCli/build.js":"let\n    color3i={\n        color:'var(--color3i)'\n    },\n    color4i={\n        color:'var(--color4i)'\n    }\n;(async()=>{\n    let[\n        Cli,\n        visualRange,\n        createTextContentCli,\n    ]=await Promise.all([\n        module.repository.Cli,\n        module.repository.visualRange,\n        module.shareImport('build/createTextContentCli.js'),\n    ])\n    function build(cli,ui,showCursor,showNumber){\n        let \n            cursor= ui._vim._trueCursor,\n            width=  ui._width,\n            height= ui._height,\n            data=   ui._wrapMethodData,\n            txt=    data.text\n        let numberWidth=ui._numberWidth\n        let textWidth=ui._textWidth\n        let text=data.text.uiText(data._scroll,data._scroll+height-1)\n        let res=createTextContentCli(\n            text,\n            cursor,\n            showCursor,\n            ui._vim._mode=='visual'&&visualRange(ui._vim),\n            ui._cursorSymbol,\n            width\n        )\n        if(showNumber){\n            cli.appendChild(number(text,numberWidth))\n            cli.appendChild({\n                child:res.textCli,\n                c:numberWidth+1,\n            })\n        }else{\n            cli.appendChild(res.textCli)\n        }\n        for(let r=res.rowsCount;r<ui.height-1;r++)\n            cli.appendChild({\n                child:'~',\n                r,\n                style:color4i\n            })\n        return cli\n    }\n    function number(text,numberWidth){\n        let cli=new Cli\n        let currentRowsCount=0\n        text.map(l=>{\n            cli.appendChild({\n                child:pad((l.index+1).toString()),\n                r:currentRowsCount,\n                style:color3i\n            })\n            currentRowsCount+=l.rows.length||1\n        })\n        return cli\n        function pad(s){\n            return ' '.repeat(numberWidth-s.length)+s\n        }\n    }\n    return build\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv/createTextCli.js":";(async()=>{\n    let[\n        Cli,\n        build,\n    ]=await Promise.all([\n        module.repository.Cli,\n        module.shareImport('createTextCli/build.js'),\n    ])\n    function createTextCli(ui){\n        return new TextCli(ui)\n    }\n    function TextCli(ui){\n        this._ui=ui\n        this._updated=false\n        this.cli=new Cli\n        this.flush()\n    }\n    TextCli.prototype.update=function(){\n        this._updated=false\n    }\n    TextCli.prototype.flush=function(){\n        if(this._updated)\n            return\n        this.cli.clear()\n        build(\n            this.cli,\n            this._ui,\n            document.activeElement==this._ui._inputTag&&\n                this._ui._vim.mode!='cmdline',\n            this._ui._vim._options.number\n        )\n        this.cli.flush()\n        this._updated=true\n    }\n    return createTextCli\n})()\n","Vim/loadUserInterface/ui/createViewNode/createCliDiv.js":"module.repository.Cli=module.shareImport('createCliDiv/Cli.js')\n;(async()=>{\n    let[\n        createCommandCli,\n        Cli,\n        createTextCli,\n        createInput,\n    ]=await Promise.all([\n        module.shareImport('createCliDiv/createCommandCli.js'),\n        module.repository.Cli,\n        module.shareImport('createCliDiv/createTextCli.js'),\n        module.shareImport('createCliDiv/createInput.js'),\n    ])\n    function createCliDiv(ui){\n        return new CliDiv(ui)\n    }\n    function CliDiv(ui){\n        this._ui=ui\n        this._vim=this._ui._vim\n        this._cli=new Cli\n        this._cliView=this._cli.view\n        this._ui._commandCli=createCommandCli(this._ui)\n        this._cliView.fontSize=this._ui._fontSize\n        this._textCli=createTextCli(this._ui)\n        this.update()\n        let n=this._cliView.node\n        this._ui._inputTag=createInput(this._ui)\n        n.appendChild(this._ui._inputTag)\n        this.node=n\n    }\n    CliDiv.prototype.modeChange=function(){\n        this._ui._commandCli.update()\n    }\n    CliDiv.prototype.update=function(){\n        let ui=this._ui\n        ui._wrapMethodData.text.width=ui._textWidth\n        ui._wrapMethodData.text.wrap()\n        ui._checkScroll()\n        this._textCli.update()\n        this._ui._commandCli.update()\n        if(this._cliView.width!=this._ui._width)\n            this._cliView.width=this._ui._width\n        if(this._cliView.height!=this._ui._height)\n            this._cliView.height=this._ui._height\n        {let c;if(c=this._cliView.symbols[this._ui._cursorSymbol]){\n            this._ui._inputTag.style.top=`${c.r*this._ui._fontSize}px`\n            this._ui._inputTag.style.left=`${c.c*this._ui._fontWidth}px`\n        }}\n        let r=this._ui._height-1\n        if(\n            this._currentR==r&&\n            this._currentWelcomeText==this._vim._welcomeText\n        )\n            return\n        this._cli.clear()\n        this._cli.appendChild(this._textCli.cli)\n        this._cli.appendChild({\n            child:this._ui._commandCli.cli,\n            r,\n        })\n        if(\n            this._vim._welcomeText&&\n            50<=this._ui.width&&\n            16<=this._ui.height\n        ){\n            let\n                r=Math.floor(\n                    (\n                        this._ui.height-\n                        this._vim._welcomeText.split('\\n').length-1\n                    )/2\n                ),\n                c=Math.floor(\n                    (this._ui.width-this._vim._welcomeText.split(\n                        '\\n'\n                    ).map(\n                        s=>s.length\n                    ).reduce(\n                        (a,b)=>Math.max(a,b)\n                    ))/2\n                )\n            this._cli.appendChild({\n                child:this._vim._welcomeText,\n                r,\n                c,\n            })\n        }\n        this._cli.flush()\n        this._currentR=r\n        this._currentWelcomeText=this._vim._welcomeText\n    }\n    CliDiv.prototype.flush=function(){\n        this._textCli.flush()\n    }\n    return createCliDiv\n})()\n","Vim/loadUserInterface/ui/createViewNode.js":";(async()=>{\n    let[\n        createCliDiv,\n    ]=await Promise.all([\n        module.shareImport('createViewNode/createCliDiv.js'),\n    ])\n    function createViewNode(ui){\n        let cliDiv=createCliDiv(ui)\n        let n=cliDiv.node\n        n.classList.add('webvim')\n        n.addEventListener('click',()=>\n            ui._vim.focus()\n        )\n        return cliDiv\n    }\n    return createViewNode\n})()\n","Vim/loadUserInterface/ui/measureWidth.js":"let ctx=document.createElement('canvas').getContext('2d')\n;((size,s)=>{\n    if(s==undefined)\n        s='a'\n    ctx.font=`${size}px monospace`\n    return ctx.measureText(s).width\n})\n","Vim/loadUserInterface/ui/prototype._updateByVim.js":"function optionChange(ui,options){\n    for(let k of options)switch(k){\n        case 'list':\n            if(ui._wrapMethod=='greedy')\n                ui._wrapMethodData.text.setOption(\n                    'list',ui._vim._options[k]\n                )\n            break\n        case 'number':\n            ui._wrapMethodData.text.width=ui._textWidth\n            break\n    }\n}\n;(function(changed){\n    for(let k in changed){let v=changed[k]\n        switch(k){\n            case 'mode':\n                this._viewNode.modeChange()\n                break\n            case 'text':\n                if(this._wrapMethod=='greedy'){\n                    if(this._sync&&this._vim._text!='')\n                        v.map(u=>\n                            this._wrapMethodData.text.update=u\n                        )\n                    else\n                        this._wrapMethodData.text.update=\n                            this._vim._trueText\n                    this._sync=\n                        this._vim._text==this._wrapMethodData.text.string\n                }\n                break\n            case 'options':\n                optionChange(this,Object.keys(v))\n                break\n        }\n    }\n    this._update()\n})\n","Vim/loadUserInterface/ui/stringWidth.js":"module.repository.npm.stringWidth.then(npmStringWidth=>{\n    function charWidth(c){\n        if(c=='\\t')\n            return 8\n        return npmStringWidth(c)\n    }\n    function stringWidth(s){\n        let res=0\n        for(let i=0;i<s.length;i++)\n            res+=charWidth(s[i])\n        return res\n    }\n    return stringWidth\n})\n","Vim/loadUserInterface/ui.js":"module.repository.measureWidth= module.shareImport('ui/measureWidth.js')\nmodule.repository.stringWidth=  module.shareImport('ui/stringWidth.js')\nlet _updateByVim=module.shareImport('ui/prototype._updateByVim.js')\n;(async()=>{\n    let[\n        measureWidth,\n        GreedyText,\n        createViewNode,\n    ]=await Promise.all([\n        module.repository.measureWidth,\n        module.shareImport('ui/GreedyText.js'),\n        module.shareImport('ui/createViewNode.js'),\n    ])\n    function Ui(vim){\n        this._values={\n            clockCycle:16,\n        }\n        this._vim=vim\n        this._width=80\n        this._height=24\n        this._fontSize=13\n        this._wrapMethod='greedy'\n        this._cursorSymbol=Symbol()\n        this._viewNode=createViewNode(this)\n        this.node=this._viewNode.node\n        setUpClock(this)\n    }\n    Object.defineProperty(Ui.prototype,'_fontSize',{set(v){\n        this._values._fontSize=v\n        this._values._fontWidth=measureWidth(this._fontSize)\n    },get(){\n        return this._values._fontSize\n    }})\n    Object.defineProperty(Ui.prototype,'_fontWidth',{get(){\n        return this._values._fontWidth\n    }})\n    Object.defineProperty(Ui.prototype,'_numberWidth',{get(){\n        return Math.max(3,Math.floor(\n            Math.log(this._vim._trueCursor._countOfRows)/Math.log(10)\n        )+1)\n    }})\n    Object.defineProperty(Ui.prototype,'_textWidth',{get(){\n        return this._vim._options.number?\n            this._width-(this._numberWidth+1)\n        :\n            this._width\n    }})\n    Ui.prototype._checkScroll=function(){\n        let\n            height=         this._height,\n            data=           this._wrapMethodData,\n            txt=            data.text,\n            c=              this._vim._trueCursor,\n            cursorViewRow=  txt.row(c._countOfCols==0?c.line(c.r):c.abs)\n        if(data._scroll+height-1<=cursorViewRow)\n            data._scroll=cursorViewRow-(height-1)+1\n        if(cursorViewRow<data._scroll)\n            data._scroll=cursorViewRow\n    }\n    Ui.prototype._update=function(){\n        this._viewNode.update()\n    }\n    Ui.prototype._updateByVim=await _updateByVim\n    Object.defineProperty(Ui.prototype,'_wrapMethod',{set(val){\n        this._values.wrapMethod=val\n        if(this._values.wrapMethod=='greedy'){\n            let text=new GreedyText\n            text.width=this._textWidth\n            text.update=this._vim._trueText\n            text.setOption('list',this._vim._options.list)\n            this._wrapMethodData={\n                _scroll:0,\n                text,\n            }\n        }else if(this._values.wrapMethod=='fixed'){\n            this._wrapMethodData={\n                _scroll:0,\n            }\n        }\n    },get(){\n        return this._values.wrapMethod\n    }})\n    Object.defineProperty(Ui.prototype,'width',{set(val){\n        this._width=val\n        this._update()\n    },get(){\n        return this._width\n    }})\n    Object.defineProperty(Ui.prototype,'height',{set(val){\n        this._height=val\n        this._update()\n    },get(){\n        return this._height\n    }})\n    Ui.prototype.focus=function(){\n        this._inputTag.focus()\n    }\n    Object.defineProperty(Ui.prototype,'free',{get(){\n        tearDownClock(this)\n        this._vim.removeUi(this)\n    }})\n    function setUpClock(ui){\n        ui._clockIntervalId=setInterval(()=>\n            ui._viewNode.flush()\n        ,ui._values.clockCycle)\n    }\n    function tearDownClock(ui){\n        clearInterval(ui._clockIntervalId)\n        delete ui._clockIntervalId\n    }\n    return{get(){\n        let ui=new Ui(this)\n        this._uis.add(ui)\n        return ui\n    }}\n})()\n","Vim/loadUserInterface/visualRange.js":"(vim=>{\n    let\n        c=vim._modeData.cursor,\n        d=vim._trueCursor.abs\n    if(d<c)[c,d]=[d,c]\n    return{s:c,e:d+1}\n})\n","Vim/loadUserInterface.js":"module.repository.visualRange=\n    module.shareImport('loadUserInterface/visualRange.js')\nPromise.all([\n    module.shareImport('loadUserInterface/input.js'),\n    module.shareImport('loadUserInterface/ui.js'),\n]).then(modules=>{\n    return o=>{\n        Object.defineProperty(o,'cursor',{get(){\n            return this._cursor.abs\n        }})\n        Object.defineProperty(o,'mode',{get(){\n            return this._mode\n        }})\n        Object.defineProperty(o,'text',{\n            set(val){\n                this._text=val\n                this._welcomeText=undefined\n                this._undoBranchManager.clear()\n                this._undoBranchManager.push(this._text)\n                this._ui()\n            },get(){\n                return this._text\n            }\n        })\n        o.focus=function(){\n            this._mainUi.focus()\n        }\n        Object.defineProperty(o,'input',modules[0])\n        Object.defineProperty(o,'ui',modules[1])\n    }\n})\n","Vim/rc.js":"(vim=>{\n    let vimrc=vim._read('~/.vimrc')\n    if(vimrc==undefined)\n        return\n    vimrc.split('\\n').map(c=>{\n        if(!c)\n            return\n        vim._mode='cmdline'\n        vim._modeData.inputBuffer=':'\n        vim._modeData.cursor.position=1\n        vim.input=c\n        vim.input={key:'Enter'}\n    })\n})\n","Vim/style.css":"div.webvim.cli{\n    position:relative;\n    font-family:monospace;\n    white-space:pre;\n    line-height:1;\n    color:var(--foreground-color);\n    background-color:var(--background-color);\n    cursor:default;\n    user-select:none;\n}\ndiv.webvim.cli>div{\n    position:absolute;\n}\ndiv.webvim.cli>textarea.input{\n    font-family:monospace;\n    position:absolute;\n    border:0;\n    padding:0;\n    resize:none;\n    overflow:hidden;\n    outline:none;\n    width:0;\n    color:var(--background-color);\n    background-color:var(--foreground-color);\n    z-index:1;\n}\n"}).map(([k,v])=>module.static(k,v));{
    let moduleNode=`https://cdn.rawgit.com/anliting/module/${
        '0e94e04505484aaf3b367423b36cf426a4242006'
    }/node`
    if(!module.repository.npm)
        module.repository.npm={}
    if(!module.repository.npm.stringWidth)
        module.repository.npm.stringWidth=module.importByPath(
            `${moduleNode}/string-width.js`
        )
    if(!module.repository.npm.events)
        module.repository.npm.events=module.importByPath(
            `${moduleNode}/events.js`
        )
}
let load=[
    module.shareImport('Vim/loadBase.js'),
    module.shareImport('Vim/loadUserInterface.js'),
    module.shareImport('Vim/loadSyntacticSugar.js'),
]
;(async()=>{
    let[
        colors,
        createCursor,
        rc,
        defaultOptions,
        StyleManager,
        UndoBranchManager,
        style,
        EventEmmiter,
    ]=await Promise.all([
        module.get('Vim/colors.css'),
        module.shareImport('Vim/createCursor.js'),
        module.shareImport('Vim/rc.js'),
        module.shareImport('Vim/defaultOptions.js'),
        module.shareImport('Vim/StyleManager.js'),
        module.shareImport('Vim/UndoBranchManager.js'),
        module.get('Vim/style.css'),
        module.repository.npm.events
    ])
    function Vim(read,write){
        EventEmmiter.call(this)
        this._values={
            mode:'normal'
        }
        this._options=Object.create(defaultOptions)
        this._viewChanged=[]
        this._text=''
        this._registers={}
        this._modeData={}
        {let a=createCursor(this)
            this._cursor=a[0]
            this._trueCursor=a[1]
        }
        this._undoBranchManager=new UndoBranchManager
        this._undoBranchManager.push(this._text)
        this._styleManager=new StyleManager
        this.style=this._styleManager.style
        this._styleManager.appendChild(document.createTextNode(style))
        this._styleManager.appendChild(document.createTextNode(colors))
        this.read=read
        this.write=write
        this._uis=new Set
        rc(this)
    }
    Object.setPrototypeOf(Vim.prototype,EventEmmiter.prototype)
    ;(await Promise.all(load)).map(f=>f(Vim.prototype))
    return Vim
})()
